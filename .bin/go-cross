#!/bin/bash

# go-cross [go binary]
#
# go-cross builds the main package under the current directory for all the first
# class Go ports. The optional parameter configures which Go command to build with.
# The build happens via GOPROXY, which allows embedding a useful module version.
# We can avoid that step once https://go.dev/issue/50603 is implemented.
#
# This script is meant to meet my needs. If you need more, copy and adapt it.

# Consistently turn cgo off, even for our local GOOS/GOARCH.
export CGO_ENABLED=0

# Since we use GOAMD64=v3 locally,
# turn that off for cross-builds for greater compatibility.
export GOAMD64=v1

gocmd=${1:-"go"}
version=${2:-"$(git describe --dirty --tags)"}
outdir=$PWD
name=$(basename "$PWD")
goexe=$($gocmd env GOEXE)

tmpdir=$(mktemp -d --suffix 'go-cross')
finish() { rm -rf tmpdir; }
trap finish EXIT

echo "Building version ${version} with $($gocmd version) from ${tmpdir}"

read modpath pkgpath < <($gocmd list -f '{{.Module.Path}} {{.ImportPath}}' .)
vcshead=$(git rev-parse HEAD)

# Use a temporary module to resolve via GOPROXY. See the docs above.
cd "$tmpdir"
$gocmd mod init test
$gocmd get ${modpath}@${vcshead}

while read goos goarch; do
	(
		export GOOS=$goos GOARCH=$goarch
		out=${name}_${version}_${goos}_${goarch}${goexe}
		$gocmd build -trimpath -ldflags="-w -s" -o="${outdir}/${out}" ${pkgpath}
		echo $out
	) &
done < <(
	# "dist list -json" gives us a list of all targets in JSON format.
	# Flatten the list, and only keep the first-class ports.
	# Then print the GOOS/GOARCH pairs in a way that shell can easily read.
	$gocmd tool dist list -json | jq -r '.[] | select(.FirstClass) | [.GOOS, .GOARCH] | @tsv'
)

wait
